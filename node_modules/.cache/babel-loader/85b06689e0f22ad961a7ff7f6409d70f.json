{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction angleToValue(params) {\n  const {\n    angle,\n    minValue,\n    maxValue,\n    startAngle,\n    endAngle\n  } = params;\n\n  if (endAngle <= startAngle) {\n    throw new Error(\"endAngle must be greater than startAngle\");\n  }\n\n  if (angle < startAngle) {\n    return minValue;\n  } else if (angle > endAngle) {\n    return maxValue;\n  } else {\n    const ratio = (angle - startAngle) / (endAngle - startAngle);\n    const value = ratio * (maxValue - minValue) + minValue;\n    return value;\n  }\n}\n\nexports.angleToValue = angleToValue;\n\nfunction valueToAngle(params) {\n  const {\n    value,\n    minValue,\n    maxValue,\n    startAngle,\n    endAngle\n  } = params;\n\n  if (endAngle <= startAngle) {\n    throw new Error(\"endAngle must be greater than startAngle\");\n  }\n\n  const ratio = (value - minValue) / (maxValue - minValue);\n  const angle = ratio * (endAngle - startAngle) + startAngle;\n  return angle;\n}\n\nexports.valueToAngle = valueToAngle;\n\nfunction convertAngle(degree, from, to) {\n  to = to || {\n    direction: \"ccw\",\n    axis: \"+x\"\n  };\n\n  if (from.direction !== to.direction) {\n    degree = degree === 0 ? 0 : 360 - degree;\n  }\n\n  if (from.axis === to.axis) {\n    return degree;\n  }\n\n  if (from.axis[1] === to.axis[1]) {\n    return (180 + degree) % 360;\n  }\n\n  switch (to.direction + from.axis + to.axis) {\n    case \"ccw+x-y\":\n    case \"ccw-x+y\":\n    case \"ccw+y+x\":\n    case \"ccw-y-x\":\n    case \"cw+y-x\":\n    case \"cw-y+x\":\n    case \"cw-x-y\":\n    case \"cw+x+y\":\n      return (90 + degree) % 360;\n\n    case \"ccw+y-x\":\n    case \"ccw-y+x\":\n    case \"ccw+x+y\":\n    case \"ccw-x-y\":\n    case \"cw+x-y\":\n    case \"cw-x+y\":\n    case \"cw+y+x\":\n    case \"cw-y-x\":\n      return (270 + degree) % 360;\n\n    default:\n      throw new Error(\"Unhandled conversion\");\n  }\n}\n\nfunction angleToPosition(angle, radius, svgSize) {\n  const angleConverted = convertAngle(angle.degree, angle, {\n    direction: \"ccw\",\n    axis: \"+x\"\n  });\n  const angleInRad = angleConverted / 180 * Math.PI;\n  let dX;\n  let dY;\n\n  if (angleInRad <= Math.PI) {\n    if (angleInRad <= Math.PI / 2) {\n      dY = Math.sin(angleInRad) * radius;\n      dX = Math.cos(angleInRad) * radius;\n    } else {\n      dY = Math.sin(Math.PI - angleInRad) * radius;\n      dX = Math.cos(Math.PI - angleInRad) * radius * -1;\n    }\n  } else {\n    if (angleInRad <= Math.PI * 1.5) {\n      dY = Math.sin(angleInRad - Math.PI) * radius * -1;\n      dX = Math.cos(angleInRad - Math.PI) * radius * -1;\n    } else {\n      dY = Math.sin(2 * Math.PI - angleInRad) * radius * -1;\n      dX = Math.cos(2 * Math.PI - angleInRad) * radius;\n    }\n  }\n\n  const x = dX + svgSize / 2;\n  const y = svgSize / 2 - dY;\n  return {\n    x,\n    y\n  };\n}\n\nexports.angleToPosition = angleToPosition;\n\nfunction positionToAngle(position, svgSize, angleType) {\n  const dX = position.x - svgSize / 2;\n  const dY = svgSize / 2 - position.y;\n  let theta = Math.atan2(dY, dX);\n\n  if (theta < 0) {\n    theta = theta + 2 * Math.PI;\n  }\n\n  const degree = theta / Math.PI * 180;\n  return convertAngle(degree, {\n    direction: \"ccw\",\n    axis: \"+x\"\n  }, angleType);\n}\n\nexports.positionToAngle = positionToAngle;\n\nfunction semiCircle(opts) {\n  const {\n    startAngle,\n    endAngle,\n    radius,\n    svgSize,\n    direction,\n    angleType\n  } = opts;\n  const startPosition = angleToPosition(Object.assign({\n    degree: startAngle\n  }, angleType), radius, svgSize);\n  const endPosition = angleToPosition(Object.assign({\n    degree: endAngle\n  }, angleType), radius, svgSize);\n  return `\n    M ${svgSize / 2},${svgSize / 2}\n    L ${startPosition.x},${startPosition.y}\n    A ${radius} ${radius} 0 ${direction === \"cw\" ? \"1 1\" : \"0 0\"}\n      ${endPosition.x} ${endPosition.y}\n    Z\n  `;\n}\n\nexports.semiCircle = semiCircle;","map":{"version":3,"sources":["C:/Fund/soft/admin/node_modules/react-circular-slider-svg/dist/circularGeometry.js"],"names":["Object","defineProperty","exports","value","angleToValue","params","angle","minValue","maxValue","startAngle","endAngle","Error","ratio","valueToAngle","convertAngle","degree","from","to","direction","axis","angleToPosition","radius","svgSize","angleConverted","angleInRad","Math","PI","dX","dY","sin","cos","x","y","positionToAngle","position","angleType","theta","atan2","semiCircle","opts","startPosition","assign","endPosition"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction angleToValue(params) {\n    const { angle, minValue, maxValue, startAngle, endAngle } = params;\n    if (endAngle <= startAngle) {\n        throw new Error(\"endAngle must be greater than startAngle\");\n    }\n    if (angle < startAngle) {\n        return minValue;\n    }\n    else if (angle > endAngle) {\n        return maxValue;\n    }\n    else {\n        const ratio = (angle - startAngle) / (endAngle - startAngle);\n        const value = ratio * (maxValue - minValue) + minValue;\n        return value;\n    }\n}\nexports.angleToValue = angleToValue;\nfunction valueToAngle(params) {\n    const { value, minValue, maxValue, startAngle, endAngle } = params;\n    if (endAngle <= startAngle) {\n        throw new Error(\"endAngle must be greater than startAngle\");\n    }\n    const ratio = (value - minValue) / (maxValue - minValue);\n    const angle = ratio * (endAngle - startAngle) + startAngle;\n    return angle;\n}\nexports.valueToAngle = valueToAngle;\nfunction convertAngle(degree, from, to) {\n    to = to || { direction: \"ccw\", axis: \"+x\" };\n    if (from.direction !== to.direction) {\n        degree = degree === 0 ? 0 : 360 - degree;\n    }\n    if (from.axis === to.axis) {\n        return degree;\n    }\n    if (from.axis[1] === to.axis[1]) {\n        return (180 + degree) % 360;\n    }\n    switch (to.direction + from.axis + to.axis) {\n        case \"ccw+x-y\":\n        case \"ccw-x+y\":\n        case \"ccw+y+x\":\n        case \"ccw-y-x\":\n        case \"cw+y-x\":\n        case \"cw-y+x\":\n        case \"cw-x-y\":\n        case \"cw+x+y\":\n            return (90 + degree) % 360;\n        case \"ccw+y-x\":\n        case \"ccw-y+x\":\n        case \"ccw+x+y\":\n        case \"ccw-x-y\":\n        case \"cw+x-y\":\n        case \"cw-x+y\":\n        case \"cw+y+x\":\n        case \"cw-y-x\":\n            return (270 + degree) % 360;\n        default:\n            throw new Error(\"Unhandled conversion\");\n    }\n}\nfunction angleToPosition(angle, radius, svgSize) {\n    const angleConverted = convertAngle(angle.degree, angle, {\n        direction: \"ccw\",\n        axis: \"+x\"\n    });\n    const angleInRad = (angleConverted / 180) * Math.PI;\n    let dX;\n    let dY;\n    if (angleInRad <= Math.PI) {\n        if (angleInRad <= Math.PI / 2) {\n            dY = Math.sin(angleInRad) * radius;\n            dX = Math.cos(angleInRad) * radius;\n        }\n        else {\n            dY = Math.sin(Math.PI - angleInRad) * radius;\n            dX = Math.cos(Math.PI - angleInRad) * radius * -1;\n        }\n    }\n    else {\n        if (angleInRad <= Math.PI * 1.5) {\n            dY = Math.sin(angleInRad - Math.PI) * radius * -1;\n            dX = Math.cos(angleInRad - Math.PI) * radius * -1;\n        }\n        else {\n            dY = Math.sin(2 * Math.PI - angleInRad) * radius * -1;\n            dX = Math.cos(2 * Math.PI - angleInRad) * radius;\n        }\n    }\n    const x = dX + svgSize / 2;\n    const y = svgSize / 2 - dY;\n    return { x, y };\n}\nexports.angleToPosition = angleToPosition;\nfunction positionToAngle(position, svgSize, angleType) {\n    const dX = position.x - svgSize / 2;\n    const dY = svgSize / 2 - position.y;\n    let theta = Math.atan2(dY, dX);\n    if (theta < 0) {\n        theta = theta + 2 * Math.PI;\n    }\n    const degree = (theta / Math.PI) * 180;\n    return convertAngle(degree, {\n        direction: \"ccw\",\n        axis: \"+x\"\n    }, angleType);\n}\nexports.positionToAngle = positionToAngle;\nfunction semiCircle(opts) {\n    const { startAngle, endAngle, radius, svgSize, direction, angleType } = opts;\n    const startPosition = angleToPosition(Object.assign({ degree: startAngle }, angleType), radius, svgSize);\n    const endPosition = angleToPosition(Object.assign({ degree: endAngle }, angleType), radius, svgSize);\n    return `\n    M ${svgSize / 2},${svgSize / 2}\n    L ${startPosition.x},${startPosition.y}\n    A ${radius} ${radius} 0 ${direction === \"cw\" ? \"1 1\" : \"0 0\"}\n      ${endPosition.x} ${endPosition.y}\n    Z\n  `;\n}\nexports.semiCircle = semiCircle;\n"]},"metadata":{},"sourceType":"script"}